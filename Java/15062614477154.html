<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  java基础巩固笔记(4)-代理 - 
  
  </title>
 <meta name="description" content="">
 <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html"></a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>javaSE</label></li>

          
            <li><a title="java基础巩固笔记(4)-代理" href="15062614477154.html">java基础巩固笔记(4)-代理</a></li>
          
            <li><a title="java基础巩固笔记(3)-类加载器" href="15062185158014.html">java基础巩固笔记(3)-类加载器</a></li>
          
            <li><a title="java基础巩固笔记(2)-泛型" href="15060875600181.html">java基础巩固笔记(2)-泛型</a></li>
          
            <li><a title="java基础巩固笔记(1)-反射" href="15060870386275.html">java基础巩固笔记(1)-反射</a></li>
          

      
        <li class="divider"></li>
        <li><label>javaWeb</label></li>

          
            <li><a title="javaweb入门笔记(1)-Tomcat" href="15060873277976.html">javaweb入门笔记(1)-Tomcat</a></li>
          

      
        <li class="divider"></li>
        <li><label>springMVC</label></li>

          
            <li><a title="springmvc笔记（19）-GET请求乱码深入剖析" href="15066056563587.html">springmvc笔记（19）-GET请求乱码深入剖析</a></li>
          
            <li><a title="springmvc笔记(18)-json数据交互" href="15062194172218.html">springmvc笔记(18)-json数据交互</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>javaSE</span></li>
                        
                          <li><a title="java基础巩固笔记(4)-代理" href="15062614477154.html">java基础巩固笔记(4)-代理</a></li>
                        
                          <li><a title="java基础巩固笔记(3)-类加载器" href="15062185158014.html">java基础巩固笔记(3)-类加载器</a></li>
                        
                          <li><a title="java基础巩固笔记(2)-泛型" href="15060875600181.html">java基础巩固笔记(2)-泛型</a></li>
                        
                          <li><a title="java基础巩固笔记(1)-反射" href="15060870386275.html">java基础巩固笔记(1)-反射</a></li>
                        

                    
                      <li class="side-title"><span>javaWeb</span></li>
                        
                          <li><a title="javaweb入门笔记(1)-Tomcat" href="15060873277976.html">javaweb入门笔记(1)-Tomcat</a></li>
                        

                    
                      <li class="side-title"><span>springMVC</span></li>
                        
                          <li><a title="springmvc笔记（19）-GET请求乱码深入剖析" href="15066056563587.html">springmvc笔记（19）-GET请求乱码深入剖析</a></li>
                        
                          <li><a title="springmvc笔记(18)-json数据交互" href="15062194172218.html">springmvc笔记(18)-json数据交互</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 <div class="markdown-body">
<h1>java基础巩固笔记(4)-代理</h1>

<p>标签： java</p>

<hr/>

<p><strong>Contents</strong></p>

<ul>
<li><a href="#java%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B04-%E4%BB%A3%E7%90%86">java基础巩固笔记(4)-代理</a>

<ul>
<li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">动态代理</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E7%B1%BB">创建动态类</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">动态代理的工作原理</a></li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B">面向切面编程</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul></li>
</ul>

<hr/>

<p>代理是实现AOP(Aspect oriented program，面向切面编程)的核心和关键技术。</p>

<h2 id="toc_0">概念</h2>

<p>代理是一种设计模式，其目的是为其他对象提供一个代理以控制对某个对象的访问，代理类负责为委托类预处理消息，过滤消息并转发消息以及进行消息被委托类执行后的后续处理。为了保持行为的一致性，代理类和委托类通常会实现相同的接口</p>

<ul>
<li>静态代理：由程序员创建代理类或特定工具自动生成源代码再对其编译，也就是说在程序运行前代理类的.class文件就已经存在。</li>
<li>动态代理：在程序运行时运用反射机制动态创建生成。</li>
</ul>

<p><img src="http://7xph6d.com1.z0.glb.clouddn.com/javaSE_%E4%BB%A3%E7%90%86%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="代理架构图"/></p>

<p><em>紫色箭头代表类的继承关系，红色连线表示调用关系</em></p>

<h2 id="toc_1">动态代理</h2>

<ul>
<li>JVM可以在运行期动态生成类的字节码，该类往往被用作动态代理类。</li>
<li>JVM生成的动态类必须实现一个或多个接口，所以这种只能用作具有相同接口的目标类的代理。</li>
<li>CGLIB库可以动态生成一个类的子类，一个类的子类也可作为该类的代理，这个可用来为没有实现接口的类生成动态代理类。</li>
<li>代理类可在<em>调用目标方法之前、之后、前后、以及处理目标方法异常的catch块中</em>添加系统功能代码。</li>
</ul>

<h3 id="toc_2">创建动态类</h3>

<p>API:</p>

<blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/reflect/Proxy.html">java.lang.reflect:Class Proxy</a>
<a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/reflect/InvocationHandler.html">java.lang.reflect:Interface InvocationHandler</a></p>
</blockquote>

<ul>
<li>查看代理类方法列表信息</li>
</ul>

<pre><code class="language-java">package com.iot.proxy;

import java.lang.reflect.*;
import java.util.ArrayList;
import java.util.Collection;

/**
 * Created by brian on 2015/12/27.
 */
public class ProxyTest {
    public static void main(String[] args) throws Exception {
        Class clazzProxy1 = Proxy.getProxyClass(Collection.class.getClassLoader(), Collection.class);
        System.out.println(clazzProxy1);
        printConstructors(clazzProxy1);
        printMethods(clazzProxy1);

    }

    /**
     * 打印构造方法列表
     * @param clazz
     */
    public static void printConstructors(Class clazz){
        System.out.println(&quot;-------------constructors list-------------&quot;);
        Constructor[] constructors = clazz.getConstructors();
        System.out.print(getExecutableList(constructors));
    }

    /**
     * 打印成员方法列表
     * @param clazz
     */
    public static void printMethods(Class clazz) {
        System.out.println(&quot;-------------methods list-------------&quot;);
        Method[] methods = clazz.getMethods();
        System.out.print(getExecutableList(methods));
    }

    /**
     * 获取要打印的列表数据
     * 每行一个方法,按照func(arg1,arg2)的格式
     * @param executables
     * @return
     */
    public static String getExecutableList(Executable[] executables){
        StringBuilder stringBuilder = new StringBuilder();
        for (Executable executable : executables) {
            String name = executable.getName();
            stringBuilder.append(name);
            stringBuilder.append(&quot;(&quot;);
            Class[] clazzParams = executable.getParameterTypes();
            for (Class clazzParam : clazzParams) {
                stringBuilder.append(clazzParam.getName()).append(&quot;,&quot;);
            }
            if (clazzParams != null &amp;&amp; clazzParams.length != 0) {
                stringBuilder.deleteCharAt(stringBuilder.length() - 1);
            }
            stringBuilder.append(&quot;)\n&quot;);
        }
        return stringBuilder.toString();
    }


}
</code></pre>

<p>输出结果：</p>

<pre><code>class com.sun.proxy.$Proxy0
-------------constructors list-------------
com.sun.proxy.$Proxy0(java.lang.reflect.InvocationHandler)
-------------methods list-------------
add(java.lang.Object)
remove(java.lang.Object)
equals(java.lang.Object)
toString()
hashCode()
clear()
contains(java.lang.Object)
isEmpty()
iterator()
size()
toArray([Ljava.lang.Object;)
toArray()
spliterator()
addAll(java.util.Collection)
stream()
forEach(java.util.function.Consumer)
containsAll(java.util.Collection)
removeAll(java.util.Collection)
removeIf(java.util.function.Predicate)
retainAll(java.util.Collection)
parallelStream()
isProxyClass(java.lang.Class)
getInvocationHandler(java.lang.Object)
getProxyClass(java.lang.ClassLoader,[Ljava.lang.Class;)
newProxyInstance(java.lang.ClassLoader,[Ljava.lang.Class;,java.lang.reflect.InvocationHandler)
wait()
wait(long,int)
wait(long)
getClass()
notify()
notifyAll()
</code></pre>

<ul>
<li>创建实例对象</li>
</ul>

<pre><code class="language-java">/**
 * 测试创建实例对象
 * @throws NoSuchMethodException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 * @throws InstantiationException
 */
private static void createProxyInstance( ) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
    /**
     * 方法1：先创建代理类，再使用反射创建实例对象
     */
    Class clazzProxy1 = Proxy.getProxyClass(Collection.class.getClassLoader(), Collection.class);
    Constructor constructor = clazzProxy1.getConstructor(InvocationHandler.class);
    Collection proxy1 = (Collection) constructor.newInstance(new InvocationHandler() {
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            return null;
        }
    });

    /**
     * 方法2：直接使用newProxyInstance方法创建实例对象
     */
    Collection proxy2 = (Collection)Proxy.newProxyInstance(
            Collection.class.getClassLoader(),
            new Class[]{Collection.class},
            new InvocationHandler() {
                ArrayList target = new ArrayList();
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            //ArrayList targetTmp = new ArrayList();
            System.out.println(&quot;before invoke method: &quot;+method.getName());
            return method.invoke(target,args);

        }
    });

    proxy2.add(&quot;aaa&quot;);
    proxy2.add(&quot;bbb&quot;);
    System.out.println(proxy2.size());
    System.out.println(proxy2);
    System.out.println(proxy2.getClass().getName());

}
</code></pre>

<p>输出结果：</p>

<pre><code>before invoke method: add
before invoke method: add
before invoke method: size
2
before invoke method: toString
[aaa, bbb]
com.sun.proxy.$Proxy0
</code></pre>

<p>上述代码相关说明:</p>

<ul>
<li>若将<code>method.invoke(target,args);</code>改为<code>method.invoke(proxy,args);</code>会出现死循环</li>
<li>从输出结果可知，每次调用代理类的方法，实际都是调用<code>invoke</code>方法</li>
<li>若将<code>method.invoke(target,args);</code>改为<code>method.invoke(targetTmp,args);</code>，则<code>proxy2.size()</code>为0。因为每次调用<code>invoke</code>方法时，<code>targetTmp</code>为新的局部变量</li>
<li><p><code>Object</code>类只有的<code>hashCode</code>, <code>equals</code>, or <code>toString</code>方法会被交到<code>InvocationHandler</code>，其他方法自己有实现，不交给handler,所以最后打印结果为<code>com.sun.proxy.$Proxy0</code>而不是<code>Collection</code></p></li>
<li><p><code>InvocationHandler</code>对象的运行原理**</p></li>
</ul>

<p><code>InvocationHandler</code>接口只有一个<code>invoke</code>方法，每次调用代理类的方法，即调用了<code>InvocationHandler</code>对象的<code>invoke</code>方法</p>

<p><code>invoke</code>方法涉及三个要素：</p>

<ul>
<li>代理对象</li>
<li>代理对象调用的方法</li>
<li>方法接受的参数</li>
</ul>

<p>注：Object类的<code>hashCode</code>,<code>equals</code>,<code>toString</code>方法交给invoke,其他的Object类的方法，Proxy有自己的实现。</p>

<blockquote>
<p>If a proxy interface contains a method with the same name and parameter signature as the hashCode, equals, or toString methods of java.lang.Object, when such a method is invoked on a proxy instance, the Method object passed to the invocation handler will have java.lang.Object as its declaring class. In other words, the public, non-final methods of java.lang.Object logically precede all of the proxy interfaces for the determination of which Method object to pass to the invocation handler.</p>
</blockquote>

<h3 id="toc_3">动态代理的工作原理</h3>

<p>代理类创建时需要传入一个InvocationHandler对象，client调用代理类，代理类的相应方法调用InvocationHandler的的invoke方法，InvocationHandler的invoke方法(可在其中加入日志记录、时间统计等附加功能)再找目标类的相应方法。</p>

<p><img src="http://7xph6d.com1.z0.glb.clouddn.com/javaSE_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" alt="动态代理的工作原理图"/></p>

<h3 id="toc_4">面向切面编程</h3>

<p>把切面的代码以<strong>对象</strong>的形式传递给InvocationHandler的invoke方法，invoke方法中执行该对象的方法就执行了切面的代码。</p>

<p>所以需要传递两个参数：</p>

<p>1.目标(Object target)
2.通知(自定义的adviser类)</p>

<p>定义<code>Advice</code>接口</p>

<pre><code class="language-java">public interface Advice {
    void beforeMethod(Method method);
    void aftereMethod(Method method);
}
</code></pre>

<p>一个实现<code>Advice</code>接口的类<code>MyAdvice</code>,用于打印执行方法前和执行后的时间</p>

<pre><code class="language-java">import java.lang.reflect.Method;

public class MyAdvice implements Advice{
    long beginTime = 0 ;
    @Override
    public void beforeMethod(Method method) {
        System.out.println(method.getName()+&quot; before at &quot;+beginTime);
        beginTime = System.currentTimeMillis();
    }

    @Override
    public void aftereMethod(Method method) {
        long endTime = System.currentTimeMillis();
        System.out.println(method.getName()+&quot; cost total &quot;+ (endTime-beginTime));
    }
}
</code></pre>

<p>定义一个<code>getProxy</code>方法创建实例对象,接收两个参数:目标和通知</p>

<pre><code class="language-java">private static Object getProxy(final Object target,final Advice advice){
    Object proxy = Proxy.newProxyInstance(
            target.getClass().getClassLoader(),
            target.getClass().getInterfaces(),
            new InvocationHandler() {
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    advice.beforeMethod(method);
                    Object retVal = method.invoke(target,args);
                    advice.aftereMethod(method);
                    return retVal;
                }
            }
    );
    return proxy;
}
</code></pre>

<p>调用：</p>

<pre><code class="language-java">Collection proxy3 = (Collection) getProxy(new ArrayList(),new MyAdvice());
proxy3.add(&quot;111&quot;);
proxy3.add(&quot;222&quot;);
System.out.println(proxy3.size());
</code></pre>

<p>输出:</p>

<pre><code>add before at 0
add cost total 0
add before at 1454433980839
add cost total 0
size before at 1454433980839
size cost total 0
2
</code></pre>

<h2 id="toc_5">参考资料</h2>

<blockquote>
<ul>
<li><a href="http://developer.51cto.com/art/201509/492614.htm">Java动态代理的实现机制</a></li>
<li><a href="http://www.cnblogs.com/xdp-gacl/p/3971367.html">Java基础加强总结(三)——代理(Proxy)</a></li>
</ul>
</blockquote>


</div>

<br /><br />
<hr />

<div class="row clearfix">
  <div class="large-6 columns">
	<div class="text-left" style="padding:15px 0px;">
		
	        <a href="15066056563587.html"  title="Previous Post: springmvc笔记（19）-GET请求乱码深入剖析">&laquo; springmvc笔记（19）-GET请求乱码深入剖析</a>
	    
	</div>
  </div>
  <div class="large-6 columns">
	<div class="text-right" style="padding:15px 0px;">
		
	        <a href="15062194172218.html" 
	        title="Next Post: springmvc笔记(18)-json数据交互">springmvc笔记(18)-json数据交互 &raquo;</a>
	    
	</div>
  </div>
</div>

<div class="row">
<div style="padding:0px 0.93em;" class="share-comments">

</div>
</div>
<script type="text/javascript">
	$(function(){
		var currentURL = '15062614477154.html';
		$('#side-nav a').each(function(){
			if($(this).attr('href') == currentURL){
				$(this).parent().addClass('active');
			}
		});
	});
</script>  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    


  </body>
</html>
