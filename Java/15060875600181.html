<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  java基础巩固笔记(2)-泛型 - 
  
  </title>
 <meta name="description" content="">
 <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html"></a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>javaSE</label></li>

          
            <li><a title="java基础巩固笔记(4)-代理" href="15062614477154.html">java基础巩固笔记(4)-代理</a></li>
          
            <li><a title="java基础巩固笔记(3)-类加载器" href="15062185158014.html">java基础巩固笔记(3)-类加载器</a></li>
          
            <li><a title="java基础巩固笔记(2)-泛型" href="15060875600181.html">java基础巩固笔记(2)-泛型</a></li>
          
            <li><a title="java基础巩固笔记(1)-反射" href="15060870386275.html">java基础巩固笔记(1)-反射</a></li>
          

      
        <li class="divider"></li>
        <li><label>javaWeb</label></li>

          
            <li><a title="javaweb入门笔记(1)-Tomcat" href="15060873277976.html">javaweb入门笔记(1)-Tomcat</a></li>
          

      
        <li class="divider"></li>
        <li><label>springMVC</label></li>

          
            <li><a title="springmvc笔记（19）-GET请求乱码深入剖析" href="15066056563587.html">springmvc笔记（19）-GET请求乱码深入剖析</a></li>
          
            <li><a title="springmvc笔记(18)-json数据交互" href="15062194172218.html">springmvc笔记(18)-json数据交互</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>javaSE</span></li>
                        
                          <li><a title="java基础巩固笔记(4)-代理" href="15062614477154.html">java基础巩固笔记(4)-代理</a></li>
                        
                          <li><a title="java基础巩固笔记(3)-类加载器" href="15062185158014.html">java基础巩固笔记(3)-类加载器</a></li>
                        
                          <li><a title="java基础巩固笔记(2)-泛型" href="15060875600181.html">java基础巩固笔记(2)-泛型</a></li>
                        
                          <li><a title="java基础巩固笔记(1)-反射" href="15060870386275.html">java基础巩固笔记(1)-反射</a></li>
                        

                    
                      <li class="side-title"><span>javaWeb</span></li>
                        
                          <li><a title="javaweb入门笔记(1)-Tomcat" href="15060873277976.html">javaweb入门笔记(1)-Tomcat</a></li>
                        

                    
                      <li class="side-title"><span>springMVC</span></li>
                        
                          <li><a title="springmvc笔记（19）-GET请求乱码深入剖析" href="15066056563587.html">springmvc笔记（19）-GET请求乱码深入剖析</a></li>
                        
                          <li><a title="springmvc笔记(18)-json数据交互" href="15062194172218.html">springmvc笔记(18)-json数据交互</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 <div class="markdown-body">
<h1>java基础巩固笔记(2)-泛型</h1>

<p>标签： java</p>

<hr/>

<p><strong>Contents</strong></p>

<ul>
<li><a href="#java%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B02-%E6%B3%9B%E5%9E%8B">java基础巩固笔记(2)-泛型</a>

<ul>
<li><a href="#%E6%9C%AF%E8%AF%AD">术语</a></li>
<li><a href="#%E9%80%9A%E9%85%8D%E7%AC%A6">&quot;?&quot;通配符</a></li>
<li><a href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E6%89%A9%E5%B1%95">通配符的扩展</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95">自定义泛型方法</a></li>
<li><a href="#%E6%93%A6%E9%99%A4%E5%AE%9E%E4%BE%8B">&quot;擦除&quot;实例</a></li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD">类型参数的类型推断</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB">自定义泛型类</a></li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E6%AF%94%E8%BE%83">泛型方法和泛型类的比较</a></li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%8F%8D%E5%B0%84">泛型和反射</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%BE%97%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AE%9E%E9%99%85%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0">通过反射获得泛型的实际类型参数</a></li>
</ul></li>
</ul>

<hr/>

<p>本文对泛型的基本知识进行较为全面的总结，并附上简短的代码实例，加深记忆。</p>

<p>泛型：将集合中的元素限定为一个特定的类型。</p>

<h2 id="toc_0">术语</h2>

<ul>
<li><code>ArrayList&lt;E&gt;</code> -- 泛型类型</li>
<li><code>ArrayList</code> -- 原始类型</li>
<li><code>E</code> -- 类型参数</li>
<li><code>&lt;&gt;</code> -- 读作&quot;typeof&quot;</li>
<li><code>ArrayList&lt;Integer&gt;</code> -- 参数化的类型</li>
<li><code>Integer</code> -- 实际类型参数</li>
</ul>

<p>几点注意：</p>

<ul>
<li>参数化类型和原始类型相互兼容</li>
</ul>

<pre><code class="language-java">ArrayList  collection1 = new ArrayList&lt;Integer&gt;();//通过,无warning
ArrayList&lt;Integer&gt; collection2 = new ArrayList();//通过,有warning
</code></pre>

<ul>
<li>参数化类型不考虑类型参数的继承关系</li>
</ul>

<pre><code class="language-java">ArrayList&lt;String&gt; collection3 = new ArrayList&lt;Object&gt;();//编译不通过
ArrayList&lt;Object&gt; collection4 = new ArrayList&lt;String&gt;();//编译不通过
</code></pre>

<p>但是</p>

<pre><code class="language-java">ArrayList collection5 = new ArrayList&lt;Integer&gt;();
ArrayList&lt;String&gt; collection6 = collection5;//编译通过
</code></pre>

<hr/>

<h2 id="toc_1">&quot;?&quot;通配符</h2>

<p>&quot;?&quot;表示任意类型，使用&quot;?&quot;通配符可以引用各种参数化的类型，可以调用与参数化无关的方法(如size()方法)，不能调用与参数化有关的方法(如add()方法)</p>

<h3 id="toc_2">通配符的扩展</h3>

<ul>
<li>限定通配符的上边界</li>
</ul>

<pre><code class="language-java">ArrayList&lt;? extends Number &gt; collection1= new ArrayList&lt;Integer &gt;();//编译通过
ArrayList&lt;? extends Number &gt; collection2= new ArrayList&lt;String&gt;();//编译不通过
</code></pre>

<ul>
<li>限定通配符的下边界</li>
</ul>

<pre><code class="language-java">ArrayList&lt;? super Integer &gt; collection3= new ArrayList&lt;Number &gt;();//编译通过
ArrayList&lt;? super Integer &gt; collection4= new ArrayList&lt;String&gt;();//编译不通过
</code></pre>

<hr/>

<h2 id="toc_3">自定义泛型方法</h2>

<p>C++模板函数</p>

<pre><code class="language-cpp">template &lt;class T&gt; T add(T x, T y){
    return (T)(x+y);
}
</code></pre>

<p>而java的泛型基本上完全在编译器中实现，用于编译器执行类型检查和类型判断，然后生成普通的<strong>非泛型</strong>的字节码，这种实现技术为“擦除”(erasure)。</p>

<h3 id="toc_4">&quot;擦除&quot;实例</h3>

<p>泛型是提供给javac编译器使用的，限定集合的输入类型，编译器编译带类型说明的集合时会去掉“类型”信息。</p>

<pre><code class="language-java">public class GenericTest {
    public static void main(String[] args) {
        new GenericTest().testType();
    }

    public void testType(){
        ArrayList&lt;Integer&gt; collection1 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;String&gt; collection2= new ArrayList&lt;String&gt;();
        
        System.out.println(collection1.getClass()==collection2.getClass());
        //两者class类型一样,即字节码一致
        
        System.out.println(collection2.getClass().getName());
        //class均为java.util.ArrayList,并无实际类型参数信息
    }
}
</code></pre>

<p>输出</p>

<pre><code>true
java.util.ArrayList
</code></pre>

<p><em>使用反射可跳过编译器，往某个泛型集合加入其它类型数据。</em></p>

<p>只有引用类型才能作为泛型方法的实际参数
例子：</p>

<pre><code class="language-java">public class GenericTest {
    public static void main(String[] args) {
        swap(new String[]{&quot;111&quot;,&quot;222&quot;},0,1);//编译通过
        
        //swap(new int[]{1,2},0,1);
        //编译不通过,因为int不是引用类型
        
        swap(new Integer[]{1,2},0,1);//编译通过
    }
    
    /*交换数组a 的第i个和第j个元素*/
    public static &lt;T&gt; void swap(T[]a,int i,int j){
        T temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
</code></pre>

<p>但注意基本类型<strong>有时</strong>可以作为实参，因为有<strong>自动装箱</strong>和<strong>拆箱</strong>。
例子(编译通过了)：</p>

<pre><code class="language-java">public class GenericTest {
    public static void main(String[] args) {
        new GenericTest().testType();
        int a = biggerOne(3,5);
        //int 和 double,取交为Number
        Number b = biggerOne(3,5.5);
        //String和int 取交为Object
        Object c = biggerOne(&quot;1&quot;,2);
    }
    //从x,y中返回y
    public static &lt;T&gt; T biggerOne(T x,T y){
        return y;
    }
}
</code></pre>

<p>同时，该例还表明，<strong>当实参不一致时，T取交集，即第一个共同的父类。</strong>
另外，如果用<code>Number b = biggerOne(3,5.5);</code>改为<code>String c = biggerOne(3,5.5);</code>则编译报错:</p>

<pre><code>Error:(17, 29) java: 不兼容的类型: 推断类型不符合上限
    推断: java.lang.Number&amp;java.lang.Comparable&lt;? extends java.lang.Number&amp;java.lang.Comparable&lt;?&gt;&gt;
    上限: java.lang.String,java.lang.Object
</code></pre>

<p>但是有一点没搞清楚，我在IDEA里面单步调试，发现结果如下图：
<img src="http://7xph6d.com1.z0.glb.clouddn.com/javaSE_%E6%B3%9B%E5%9E%8B%E8%B0%83%E8%AF%95%E6%88%AA%E5%9B%BE-1.png" alt="泛型调试截图-1"/>
不知道b为什么是Double类型的（但直接<code>Double b</code>接收返回值会编译报错）。不知道跟IDE有没有关系，是不是IDE在debug时会显示这个对象最精确的类型？</p>

<h3 id="toc_5">类型参数的类型推断</h3>

<p>编译器判断泛型方法的实际类型参数的过程称为类型推断。</p>

<ul>
<li>当某个类型变量只在整个参数列表的所有参数和返回值中的<strong>一处被应用</strong>了，那么根据调用方法时该处的实际应用类型来确定。即直接根据调用方法时传递的参数类型或返回值来决定泛型参数的类型。
例如：</li>
</ul>

<p><code>swap(new String[3],1,2)</code> -&gt; <code>static &lt;E&gt; void swap(E[]a,int i,int j)</code></p>

<ul>
<li>当某个类型变量在整个参数列表的所有参数和返回值中的<strong>多处被应用</strong>了，如果调用方法时这么多处的实际应用类型都 <em>对应同一种类型</em>，则泛型参数的类型就是该类型。
例如：</li>
</ul>

<p><code>add(3,5)</code> -&gt; <code>static &lt;T&gt; T add(T a,T b)</code></p>

<ul>
<li>当某个类型变量在整个参数列表的所有参数和返回值中的*<strong>多处被应用</strong>了，如果调用方法时这么多处的实际应用类型 <em>对应不同的类型,且没有返回值</em>，则取多个参数中的最大交集类型，即第一个公共父类。
例如：</li>
</ul>

<p><code>fill(new Integer[3],3.5)</code> -&gt; <code>static &lt;T&gt; void fill(T a[],T v)</code></p>

<p>该例子实际对应的类型就是Number,编译通过，运行出问题。</p>

<ul>
<li>当某个类型变量在整个参数列表的所有参数和返回值中的<strong>多处被应用</strong>了，如果调用方法时这么多处的实际应用类型<em>对应不同的类型,且使用有返回值</em>，则<strong>优先考虑返回值的类型</strong></li>
</ul>

<p>例如：</p>

<p><code>int x = add(3,3.5)</code> -&gt; <code>static &lt;T&gt; T add(T a,T b)</code></p>

<p>上例编译报错,x类型改为float也报错，改为Number成功。</p>

<ul>
<li>参数类型的类型推断具有传递性</li>
</ul>

<p>例子：</p>

<p><code>copy(new Integer[5],new String[5])</code> -&gt; <code>static &lt;T&gt; void copy(T []a,T []b)</code></p>

<p>该例推断实际参数类型为Object,编译通过.</p>

<p><code>copy(new ArrayList&lt;String&gt;,new Integer[5])</code> -&gt; <code>static &lt;T&gt; void copy(Collection&lt;T&gt;a,T[]b)</code></p>

<p>该例则根据参数化的ArrayList类实例将类型变量直接确定为String类型，编译报错。</p>

<hr/>

<h2 id="toc_6">自定义泛型类</h2>

<p>例子</p>

<pre><code class="language-java">public class GenericDao&lt;T&gt;{
    public void add(T x){
    }
    
    public T findById(int id){
        return null;
    }
    
    public void delete(T obj){
    }
    
    public void delete(int id){
    }
    
    public void update(T obj){
    }
    
    public T findByUserName(String name){
        return null;
    }

    public &lt;T&gt; Set&lt;T&gt; findByConditions(String where){
        return null;
    }
    
}
</code></pre>

<p>注意：当一个变量被声明为泛型时，只能被实例变量和方法调用(还有内嵌类型)，而不能被静态变量和静态方法调用。<em>因为静态成员是被所参数化的类所共享的，所以静态成员不应该有类级别的类型参数</em>。</p>

<h3 id="toc_7">泛型方法和泛型类的比较</h3>

<p>例子：</p>

<pre><code class="language-java">public class A&lt;T&gt;(){
    //泛型类的成员方法，该T受A后面的T的限制
    public T memberFunc(){
        return null;
    }
    //泛型方法，这里的T和和类A的T是不同的
    public static &lt;T&gt; T genericFunc(T a){
        return null;
    }
    public static void main(String[] args) {
        //编译不通过
        //Integer i = A&lt;String&gt;().findByUserName(&quot;s&quot;);
        
        //编译通过
        Set&lt;Integer&gt; set=  A&lt;String&gt;().findByConditions(&quot;s&quot;);
    }
}
</code></pre>

<p>这里<code>Integer i = A&lt;String&gt;().findByUserName(&quot;s&quot;);</code>会编译报错：</p>

<p><code>Error:(35, 61) java: 不兼容的类型: java.lang.String无法转换为java.lang.Integer</code></p>

<p>由这个例子可知，泛型方法的T和和类A的T是不同的。</p>

<hr/>

<h2 id="toc_8">泛型和反射</h2>

<h3 id="toc_9">通过反射获得泛型的实际类型参数</h3>

<p>把泛型变量当成方法的参数，利用Method类的getGenericParameterTypes方法来获取泛型的实际类型参数
例子：</p>

<pre><code class="language-java">public class GenericTest {
    public static void main(String[] args) throws Exception {
        getParamType();
    }
    
     /*利用反射获取方法参数的实际参数类型*/
    public static void getParamType() throws NoSuchMethodException{
        Method method = GenericTest.class.getMethod(&quot;applyMap&quot;,Map.class);
        //获取方法的泛型参数的类型
        Type[] types = method.getGenericParameterTypes();
        System.out.println(types[0]);
        //参数化的类型
        ParameterizedType pType  = (ParameterizedType)types[0];
        //原始类型
        System.out.println(pType.getRawType());
        //实际类型参数
        System.out.println(pType.getActualTypeArguments()[0]);
        System.out.println(pType.getActualTypeArguments()[1]);
    }

    /*供测试参数类型的方法*/
    public static void applyMap(Map&lt;Integer,String&gt; map){

    }

}
</code></pre>

<p>输出结果：</p>

<pre><code>java.util.Map&lt;java.lang.Integer, java.lang.String&gt;
interface java.util.Map
class java.lang.Integer
class java.lang.String
</code></pre>


</div>

<br /><br />
<hr />

<div class="row clearfix">
  <div class="large-6 columns">
	<div class="text-left" style="padding:15px 0px;">
		
	        <a href="15062185158014.html"  title="Previous Post: java基础巩固笔记(3)-类加载器">&laquo; java基础巩固笔记(3)-类加载器</a>
	    
	</div>
  </div>
  <div class="large-6 columns">
	<div class="text-right" style="padding:15px 0px;">
		
	        <a href="15060873277976.html" 
	        title="Next Post: javaweb入门笔记(1)-Tomcat">javaweb入门笔记(1)-Tomcat &raquo;</a>
	    
	</div>
  </div>
</div>

<div class="row">
<div style="padding:0px 0.93em;" class="share-comments">

</div>
</div>
<script type="text/javascript">
	$(function(){
		var currentURL = '15060875600181.html';
		$('#side-nav a').each(function(){
			if($(this).attr('href') == currentURL){
				$(this).parent().addClass('active');
			}
		});
	});
</script>  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    


  </body>
</html>
